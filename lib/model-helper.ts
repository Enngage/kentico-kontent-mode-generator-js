import {
    IContentType,
    ElementType,
    camelCasePropertyNameResolver,
    pascalCasePropertyNameResolver,
    snakeCasePropertyNameResolver
} from '@kentico/kontent-delivery';
import { name, version } from '../package.json';
import { format, Options } from 'prettier';
import { PropertyNameResolverType } from './models';

export class ModelHelper {
    getFilename(data: { type: IContentType }): string {
        return `${data.type.system.codename}.ts`;
    }

    getClassDefinition(data: {
        type: IContentType;
        addTimestamp: boolean;
        formatOptions?: Options;
        nameResolver?: PropertyNameResolverType;
    }): string {
        const code = `
import { IContentItem, Elements } from '@kentico/kontent-delivery';

/**
 * ${this.getAutogenerateNote(data.addTimestamp)}
*/
export type ${this.capitalize(data.type.system.codename)} = IContentItem<{
    ${this.getElementsCode({
        type: data.type,
        nameResolver: data.nameResolver
    })}
}>;
`;
        const formatOptions: Options = data.formatOptions
            ? data.formatOptions
            : {
                  parser: 'typescript',
                  singleQuote: true
              };

        // beatify code
        return format(code, formatOptions);
    }

    private getAutogenerateNote(addTimestamp: boolean): string {
        if (addTimestamp) {
            return `Generated by '${name}@${version}' at '${new Date().toUTCString()}'`;
        }

        return `Generated by '${name}@${version}'`;
    }

    private getElementsCode(data: { type: IContentType; nameResolver?: PropertyNameResolverType }): string {
        let code = '';
        for (let i = 0; i < data.type.elements.length; i++) {
            const element = data.type.elements[i];
            code += `${this.getElementName({
                elementName: element.codename,
                type: data.type.system.codename,
                nameResolver: data.nameResolver
            })}: Elements.${this.mapElementTypeToName(element.type)};`;

            if (i !== data.type.elements.length - 1) {
                code += '\n';
            }
        }

        return code;
    }

    private mapElementTypeToName(elementType: string): string {
        let result: string = '';
        if (elementType.toLowerCase() === ElementType.Text.toLowerCase()) {
            result = 'TextElement';
        } else if (elementType.toLowerCase() === ElementType.Number.toLowerCase()) {
            result = 'NumberElement';
        } else if (elementType.toLowerCase() === ElementType.ModularContent.toLowerCase()) {
            result = `LinkedItemsElement<IContentItem>`;
        } else if (elementType.toLowerCase() === ElementType.Asset.toLowerCase()) {
            result = 'AssetsElement';
        } else if (elementType.toLowerCase() === ElementType.DateTime.toLowerCase()) {
            result = 'DateTimeElement';
        } else if (elementType.toLowerCase() === ElementType.RichText.toLowerCase()) {
            result = 'RichTextElement';
        } else if (elementType.toLowerCase() === ElementType.MultipleChoice.toLowerCase()) {
            result = 'MultipleChoiceElement';
        } else if (elementType.toLowerCase() === ElementType.UrlSlug.toLowerCase()) {
            result = 'UrlSlugElement';
        } else if (elementType.toLowerCase() === ElementType.Taxonomy.toLowerCase()) {
            result = 'TaxonomyElement';
        } else if (elementType.toLowerCase() === ElementType.Custom.toLowerCase()) {
            result = 'CustomElement';
        } else {
            console.warn(`Unsupported element type '${elementType}'`);
        }
        return result;
    }

    private getElementName(config: {
        type: string;
        elementName: string;
        nameResolver?: PropertyNameResolverType;
    }): string {
        if (!config.nameResolver) {
            return config.elementName;
        }
        if (config.nameResolver === 'camelCase') {
            return camelCasePropertyNameResolver(config.type, config.elementName);
        }

        if (config.nameResolver === 'pascalCase') {
            return pascalCasePropertyNameResolver(config.type, config.elementName);
        }

        if (config.nameResolver === 'snakeCase') {
            return snakeCasePropertyNameResolver(config.type, config.elementName);
        }

        throw Error(
            `Invalid name resolver '${config.nameResolver}'. Available options are: camelCase, pascalCase, snakeCase`
        );
    }

    private capitalize(text: string): string {
        if (!text || text.length === 0) {
            return text;
        }

        return text.charAt(0).toUpperCase() + text.slice(1);
    }
}

export const modelHelper = new ModelHelper();
